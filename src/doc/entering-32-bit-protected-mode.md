# 4. 进入 32 位保护模式

如果继续在16位实模式下工作可能很美好，毕竟我们已经熟悉了这个环境，但是为了充分的利用 CPU 以及能更好的理解 CPU 体系结构的发展对现代操作系统的好处，即硬件中的内存保护。我们必须踏入 32 位保护模式。

32位保护模式主要有以下几点不同：
* 寄存器扩展到了 32 位，在寄存器前面加上 e 来访问全部的长度，例如：mov ebx, 0x274fe8fe
* 为了方便，增加来额外的 fs 和 gs 2个通用段寄存器 
* 提供 32位 的内存偏移能力，所以一个偏移量能引用惊人的4GB内存(0xffffffff)
* CPU 支持更完善的内存分段方式--尽管稍微变复杂来一点，这样的改变有2个大的好处：
- 一个段中的代码禁止执行比它特权级别高的段中的代码，这样能保护你们的内核代码免受用户应用的破坏和影响。
- CPU 能为用户进程提供虚拟内存，这样进程的内存中的页（固定大小的内存块）能在需要的时候在内存和磁盘之间透明的转换。这保证了主存使用更加高效，对于极少执行或使用的数据不需要占用宝贵的内存资源。

* 中断操作也更加完善。

关于 CPU 从 16位实模式切换到32位保护模式最难的部分是我们必须在内存中准备一个名为 全局描述表（global descriptor table GDT）的复杂数据结构，这个表用来定义内存段和它们的保护模式属性。一旦我们定义好了这个GDT， 我们就可以使用一个特殊的指令将它载入CPU，然后我们通过设置一个特殊的CPU控制寄存器中的一位来实际切换到保护模式。

如果不需要使用汇编语言来定义GDT这个过程将会很容易，但是如果后面我们希望加载一个由高级语言比如C编译的内核这种底层的切换就不可避免了。 高级语言通常会将代码编译为高效的32位指令而不是低效的16位指令。

哦，还有意见大事我差点忘了说：一旦我们进入了32位保护模式我们就不能继续使用BIOS服务了。如果你觉得调用BIOS服务是底层的。这像是退一步进两步。

## 4.1 适应没有 BIOS 的生活