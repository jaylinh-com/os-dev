(window.webpackJsonp=window.webpackJsonp||[]).push([[15],{370:function(e,t,o){"use strict";o.r(t);var a=o(42),s=Object(a.a)({},(function(){var e=this,t=e.$createElement,o=e._self._c||t;return o("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[o("h1",{attrs:{id:"_5-编写-构建-加载你的内核"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#_5-编写-构建-加载你的内核"}},[e._v("#")]),e._v(" 5.编写，构建，加载你的内核")]),e._v(" "),o("p",[e._v("So far, we have learnt a lot about how the computer really works, by communicating with it in the low-level assembly language, but we’ve also seen how it can be very slow to progress in such a language: we need to think very carefully even about the simplest of control structures (e.g. if "),o("code",[e._v("(<something>) <do this> else <do that>)")]),e._v(", and we have to worry about how best to make use of the limited number of registers, and juggle with the stack. Another drawback of us continuing in assembly language is that it is closely tied to the specific CPU architecture, and so it would be harder for us to port our operating system to another CPU architecture (e.g. ARM, RISC, PowerPC).\nLuckily, other programmers also got fed up of writing in assembly, so decided to write higher-level language compilers (e.g. FORTRAN, C, Pascal, BASIC, etc.), that would transform more intuitive code into assembly language. The idea of these compilers is to map higher level constructs, such as control structures and function calls onto assembly template code, and so the downside --- and there usually always is a downside --- is that the generic templates may not always be optimal for specific functionality. Without further ado, let us look at how C code is transformed into assembly to demystify the role of the compiler.")]),e._v(" "),o("p",[e._v("目前，我们已经学习了关于计算机怎么工作的")])])}),[],!1,null,null,null);t.default=s.exports}}]);