(window.webpackJsonp=window.webpackJsonp||[]).push([[15],{372:function(a,s,t){"use strict";t.r(s);var e=t(42),n=Object(e.a)({},(function(){var a=this,s=a.$createElement,t=a._self._c||s;return t("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[t("h1",{attrs:{id:"_5-编写-构建-加载你的内核"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_5-编写-构建-加载你的内核"}},[a._v("#")]),a._v(" 5.编写，构建，加载你的内核")]),a._v(" "),t("p",[a._v("目前，通过使用底层汇编语言与计算机交流，我们已经学习了很多关于计算机怎么工作的知识，但是我们也看到了使用汇编编程效率太低了：即使是非常简单的控制结构(例如："),t("code",[a._v("if (<something>) <do this> else <do that>")]),a._v(")我们都要非常小心的思考，并且我们还需要考虑怎么使用有限的寄存器，同时考虑栈问题。继续使用汇编语言还有一个问题，汇编语言强依赖特定的CPU 架构，所以很难将我们的操作系统移植到其他的CPU 架构上(例如：ARM， RISC， PowerPC)。")]),a._v(" "),t("p",[a._v("幸运的是，其他的编程人员也厌倦了汇编语言，所以决定编写高级语言编译器(例如： FORTRAN， C， Pascal, BASIC, 等), 这些编译器可以将更直观的代码转换为汇编语言。这些编译器的思想是将高级语言结构，例如控制结构和函数调用映射为汇编模版代码，但是通用模版并不对所有的特定函数进行优化，这也是其缺点。这里不再深入，我们继续来看看C语言代码怎么转换为汇编来揭开编译器神秘的面纱。")]),a._v(" "),t("h2",{attrs:{id:"_5-1-了解-c-编译"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_5-1-了解-c-编译"}},[a._v("#")]),a._v(" 5.1 了解 C 编译")]),a._v(" "),t("p",[a._v("让我们写一小段 C 代码 然后来看看它们会编译成什么汇编代码。这是学习关于 C 的原理的极好的方式。")]),a._v(" "),t("h3",{attrs:{id:"_5-1-1-生成原始机器码"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_5-1-1-生成原始机器码"}},[a._v("#")]),a._v(" 5.1.1 生成原始机器码")]),a._v(" "),t("div",{staticClass:"language-c extra-class"},[t("pre",{pre:!0,attrs:{class:"language-c"}},[t("code",[t("span",{pre:!0,attrs:{class:"token comment"}},[a._v("// Define an empty function that returns an integer")]),a._v("\n"),t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("int")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token function"}},[a._v("my_function")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("{")]),a._v("\n    "),t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("return")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token number"}},[a._v("0xbaba")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("}")]),a._v("\n")])])]),t("p",[a._v("将上面的代码保存到 "),t("code",[a._v("basic.c")]),a._v(" 文件中, 然后使用下面的命令编译它：\n"),t("code",[a._v("bash $gcc -ffreestanding -c basic.c -o basic.o")])]),a._v(" "),t("p",[a._v("这将生成一个 "),t("em",[a._v("对象文件")]),a._v(", 这里的对象不要与面向对象编程中的对象概念混淆来，它们互不相干。这里编译器没有将代码直接编译成机器码。而是编译输出一个含有 "),t("em",[a._v("注解")]),a._v(" 的机器码文件。这些注解元信息对程序的执行是多余的，留下它们是为了在最终合并所有的代码时提供方便。这种临时输出格式的一个最大的优势是当与其他的库中的其他程序链接的时候代码很容易的重新定位到大二进制文件中。因为对象文件中的代码使用相对地址而不是绝对内存地址引用。我们可以使用下面的命令来查看对象文件中的内容：")]),a._v(" "),t("div",{staticClass:"language-bash extra-class"},[t("pre",{pre:!0,attrs:{class:"language-bash"}},[t("code",[t("span",{pre:!0,attrs:{class:"token variable"}},[a._v("$objdump")]),a._v(" -d basic.o\n")])])]),t("p",[a._v("这个命令将产生如下图所示的内容。注意我们可以看到一些汇编指令和关于代码的一些额外信息。另外注意这里生成的汇编语法与我们使用的 nasm 语法稍微有写不同，我们将在后面看到对象文件生成我们熟悉的汇编语法，这里先简单的忽略它们的区别。")]),a._v(" "),t("div",{staticClass:"language-nasm extra-class"},[t("pre",{pre:!0,attrs:{class:"language-nasm"}},[t("code",[t("span",{pre:!0,attrs:{class:"token label function"}},[a._v("basic.o:")]),a._v("     file format elf32"),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v("-")]),a._v("i386\n\n\nDisassembly of section .text:\n\n"),t("span",{pre:!0,attrs:{class:"token number"}},[a._v("00000000")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v("<")]),a._v("my_function"),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v(">")]),a._v(":\n   "),t("span",{pre:!0,attrs:{class:"token number"}},[a._v("0")]),a._v(":   "),t("span",{pre:!0,attrs:{class:"token number"}},[a._v("55")]),a._v("                      push   "),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v("%")]),t("span",{pre:!0,attrs:{class:"token register variable"}},[a._v("ebp")]),a._v("\n   "),t("span",{pre:!0,attrs:{class:"token number"}},[a._v("1")]),a._v(":   "),t("span",{pre:!0,attrs:{class:"token number"}},[a._v("89")]),a._v(" e5                   mov    "),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v("%")]),t("span",{pre:!0,attrs:{class:"token register variable"}},[a._v("esp")]),a._v(","),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v("%")]),t("span",{pre:!0,attrs:{class:"token register variable"}},[a._v("ebp")]),a._v("\n   "),t("span",{pre:!0,attrs:{class:"token number"}},[a._v("3")]),a._v(":   b8 ba ba "),t("span",{pre:!0,attrs:{class:"token number"}},[a._v("00")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token number"}},[a._v("00")]),a._v("          mov    "),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v("$")]),t("span",{pre:!0,attrs:{class:"token number"}},[a._v("0xbaba")]),a._v(","),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v("%")]),t("span",{pre:!0,attrs:{class:"token register variable"}},[a._v("eax")]),a._v("\n   "),t("span",{pre:!0,attrs:{class:"token number"}},[a._v("8")]),a._v(":   "),t("span",{pre:!0,attrs:{class:"token number"}},[a._v("5d")]),a._v("                      pop    "),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v("%")]),t("span",{pre:!0,attrs:{class:"token register variable"}},[a._v("ebp")]),a._v("\n   "),t("span",{pre:!0,attrs:{class:"token number"}},[a._v("9")]),a._v(":   c3                      ret    \n")])])]),t("p",[a._v("为了创建实际的可执行代码(即将在CPU上运行的),我们需要使用 "),t("em",[a._v("链接器")]),a._v(", 它的作用是将输入对象文件中描述的所有的文件链接成一个可执行二进制文件，将它们拼接在一起然后在聚合的机器代码里将所有的相对地址转换成绝对地址。例如："),t("code",[a._v("call <function X label>")]),a._v(" 将变成 "),t("code",[a._v("call 0x12345")]),a._v(", 这里 "),t("code",[a._v("0x12345")]),a._v(" 是链接器决定将使用 "),t("code",[a._v("function X label")]),a._v(" 声明的程序放置到输出文件的偏移量。")]),a._v(" "),t("p",[a._v("尽管这里我们不需要链接其他对象文件中的任何程序。但是后面我们将看到链接器会将我们的含有注解的机器代码文件转换成原始机器代码文件。使用下面的命令将原始机器码文件输出到 "),t("code",[a._v("basic.bin")]),a._v(" 文件中。")]),a._v(" "),t("div",{staticClass:"language-bash extra-class"},[t("pre",{pre:!0,attrs:{class:"language-bash"}},[t("code",[t("span",{pre:!0,attrs:{class:"token variable"}},[a._v("$ld")]),a._v(" -o basic.bin -Ttext 0x0 --oformat binary basic.o\n")])])]),t("p",[a._v("注意，同编译器一样，链接器也能输出多种不同格式的可执行文件，其中的一些将保留输入对象文件中的元数据。这对于部署在操作系统上的可执行文件很有用，例如我们编写的大多数程序都是编写到例如LInux 或者 windows 的平台上，因元数据可以被留下来用于描述我们的程序将怎么被加载到内存中，另外对于调试目的也有用，例如一个进程在指令地址0x12345678处崩溃的信息对程序员来说远不如使用额外的不能执行的元数据表示的信息有用，比如进程在 "),t("code",[a._v("basic.c")]),a._v(" 文件第三行的函数 "),t("code",[a._v("my function")]),a._v(" 中崩溃.")])])}),[],!1,null,null,null);s.default=n.exports}}]);