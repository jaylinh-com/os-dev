<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>2.1 启动流程 | 手写一个简单的操作系统</title>
    <meta name="generator" content="VuePress 1.7.1">
    
    <meta name="description" content="本项目设计的目的不是替代像Minix这样的优秀项目，而是作为学习这些优秀项目以及开发操作系统的垫脚石。">
    <meta name="theme-color" content="#3eaf7c">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    
    <link rel="preload" href="/assets/css/0.styles.4904ab03.css" as="style"><link rel="preload" href="/assets/js/app.e342ee38.js" as="script"><link rel="preload" href="/assets/js/2.40f8d214.js" as="script"><link rel="preload" href="/assets/js/19.c4607430.js" as="script"><link rel="prefetch" href="/assets/js/10.e27cce2f.js"><link rel="prefetch" href="/assets/js/11.674318ae.js"><link rel="prefetch" href="/assets/js/12.0aca8105.js"><link rel="prefetch" href="/assets/js/13.871a4352.js"><link rel="prefetch" href="/assets/js/14.1f63f8f3.js"><link rel="prefetch" href="/assets/js/15.8eab6ab0.js"><link rel="prefetch" href="/assets/js/16.0c336982.js"><link rel="prefetch" href="/assets/js/17.905d6db8.js"><link rel="prefetch" href="/assets/js/18.4cd60f7d.js"><link rel="prefetch" href="/assets/js/20.3d68b7f2.js"><link rel="prefetch" href="/assets/js/3.03d08e27.js"><link rel="prefetch" href="/assets/js/4.880e7f6b.js"><link rel="prefetch" href="/assets/js/5.5ae19d78.js"><link rel="prefetch" href="/assets/js/6.73c063ed.js"><link rel="prefetch" href="/assets/js/7.294a7cdc.js"><link rel="prefetch" href="/assets/js/8.5993cf55.js"><link rel="prefetch" href="/assets/js/9.3112df6c.js">
    <link rel="stylesheet" href="/assets/css/0.styles.4904ab03.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><!----> <span class="site-name">手写一个简单的操作系统</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/" class="nav-link">
  主页
</a></div><div class="nav-item"><a href="/os-dev/introduction.html" class="nav-link">
  文档
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="切换语言Switch Languages" class="dropdown-title"><span class="title">切换语言</span> <span class="arrow down"></span></button> <button type="button" aria-label="切换语言Switch Languages" class="mobile-dropdown-title"><span class="title">切换语言</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/os-dev/computer-architecture-and-the-boot-process.html" aria-current="page" class="nav-link router-link-exact-active router-link-active">
  中文
</a></li><li class="dropdown-item"><!----> <a href="/en-US/" class="nav-link">
  English
</a></li></ul></div></div> <a href="https://github.com/jaylinh-com/os-dev" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/" class="nav-link">
  主页
</a></div><div class="nav-item"><a href="/os-dev/introduction.html" class="nav-link">
  文档
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="切换语言Switch Languages" class="dropdown-title"><span class="title">切换语言</span> <span class="arrow down"></span></button> <button type="button" aria-label="切换语言Switch Languages" class="mobile-dropdown-title"><span class="title">切换语言</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/os-dev/computer-architecture-and-the-boot-process.html" aria-current="page" class="nav-link router-link-exact-active router-link-active">
  中文
</a></li><li class="dropdown-item"><!----> <a href="/en-US/" class="nav-link">
  English
</a></li></ul></div></div> <a href="https://github.com/jaylinh-com/os-dev" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></nav>  <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><p class="sidebar-heading open"><span></span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/os-dev/introduction.html" class="sidebar-link">1.1 介绍</a></li><li><a href="/os-dev/computer-architecture-and-the-boot-process.html" aria-current="page" class="active sidebar-link">2.1 启动流程</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/os-dev/computer-architecture-and-the-boot-process.html#_2-1-启动流程" class="sidebar-link">2.1 启动流程</a></li><li class="sidebar-sub-header"><a href="/os-dev/computer-architecture-and-the-boot-process.html#_2-2-bios-引导区-魔法数字" class="sidebar-link">2.2 BIOS, 引导区，魔法数字</a></li><li class="sidebar-sub-header"><a href="/os-dev/computer-architecture-and-the-boot-process.html#_2-3-cpu-模拟" class="sidebar-link">2.3 CPU 模拟</a></li><li class="sidebar-sub-header"><a href="/os-dev/computer-architecture-and-the-boot-process.html#_2-4-十六进制表示法的优势" class="sidebar-link">2.4 十六进制表示法的优势</a></li></ul></li><li><a href="/os-dev/boot-sector-programming.html" class="sidebar-link">3.1 启动扇区编程</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/os-dev/boot-sector-programming.html#_3-2-16位实模式" class="sidebar-link">3.2 16位实模式</a></li><li class="sidebar-sub-header"><a href="/os-dev/boot-sector-programming.html#_3-3-嗯-hello" class="sidebar-link">3.3 嗯， Hello ?</a></li><li class="sidebar-sub-header"><a href="/os-dev/boot-sector-programming.html#_3-4-hello-world" class="sidebar-link">3.4 Hello World!</a></li></ul></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h2 id="_2-1-启动流程"><a href="#_2-1-启动流程" class="header-anchor">#</a> 2.1 启动流程</h2> <p>现在，让我们开始我们的旅程吧。</p> <p>当我们重启我们的计算机时，它必须重新初始化并没有任何操作系统相关的概念, 然而，它必须从某种(例如：软盘，硬盘，usb等)固定储存设备上加载操作系统，任何发行版都行。</p> <p>我们马上就会发现，再操作系统之前的环境中我们的计算机在丰富的服务方面提供的很少：再这一阶段即使时一个简单的文件系统也是很奢侈的（比如磁盘上逻辑文件的读写），但是我们没有。幸运的是，我们有Basic Input/Output Software (BIOS)基本输入输出服务，一组软件服务当计算机开机的时候从芯片加载到内存中并初始化。BIOS 提供计算机关键设备的自检和基本控制能力，例如；显示器、键盘和硬盘。</p> <p>在BIOS完成对硬件的基本检测后，特别是安装的内存是否能正常的工作，它必须引导储存再你设备种的操作系统了。这里我们知道，尽管BIOS不能简单从硬盘加载操作系统的文件。因为BIOS没有文件系统的概念。BIOS必须从磁盘设备上特定的物理地址上读取数据的特定扇区（通常是512B）,例如：</p> <p>所以，对于BIOS来说找到OS最简单的位置就是某个磁盘的第一个扇区，被称为 boot sector（引导扇区），因为我们有些磁盘没有包含操作系统-这些磁盘可能只是简单的提供额外的储存，所以对于BIOS来说判断某个磁盘的引导扇区是否是需要执行的引导代码还是普通的数据很重要，注意CPU不能区分代码和数据，这些都能被翻译为CPU指令，代码只是编程者编写为有用算法的指令。
继续，BIOS采用了一个简单的方法：目标引导扇区的最后2个字节必须设置为魔法数字 0xaa55. 所以BIOS遍历每一个存储设备（软盘、硬盘、CD 等），然后让CPU执行它发现的第一个以魔法数字结束的引导扇区，
这就是我们获取计算机控制权的地方。</p> <h2 id="_2-2-bios-引导区-魔法数字"><a href="#_2-2-bios-引导区-魔法数字" class="header-anchor">#</a> 2.2 BIOS, 引导区，魔法数字</h2> <p>如果我们有二进制编辑器，例如 TextPad 或者GHex, 我们可以使用这些编辑器来编写原始的字节到文件中，而不是像标准文本编辑器会转化字符，例如将'A'转化为ASCII值，这样我们可以为自己制作一个简单并且有效的引导扇区。</p> <div class="language- extra-class"><pre class="language-text"><code>e9 fd ff 00 00 00 00 00 00 00 00 00 00 00 00 00
00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 *
00 00 00 00 00 00 00 00 00 00 00 00 00 00 55 aa
</code></pre></div><p>图表 2.1： 一个机器代码的引导扇区，每一个字节都是用16进制数表示。
注意在表2.1中，有3个重要特点：</p> <ul><li>最开始的三个字节用16进制表示分别是 0xe9,0xfd和0xff 实际上都是生产商定义的机器代码指令，用户无条件跳转的。</li> <li>最后2个字节 0x55和0xaa组成了魔法数字，这些数字告诉BIOS这确定是一个引导区而不是碰巧位于引导扇区的数据。</li> <li>文件中填充了0（'*'表示为简洁起见省略了0），基本上是为了将magic BIOS魔法数字定位在512字节磁盘扇区的末尾。</li></ul> <p>关于字节序我们需要特别注意：你可能会疑惑我们之前表述魔法数字的时候是用16位值 0xaa55 表示的，而我们在引导扇区写的却是Ox55和0xaa 两个连续的字节。这是因为 x86结构是使用小端格式（低字节序）来处理多字节值的。与我们通常所熟悉的数字系统相反，小端格式是将低位字节放到高位字节的前面。
假如我们的系统发生了端格式的转换，即使我的账户里面只有0000005磅，我也能马上退休，或许还可以给前百万富翁基金捐赠几磅。</p> <p>编译器和汇编器可以通过让我们指定数据的类型来隐藏很多端格式的问题。比如说，一个16位的值能够自动序列化为机器代码，并且他的字节顺序是正确的。</p> <p>但是有时它很有用，特别是当我们查找bug 的时候能够确切的知道单个字节再储存设备或内存中的位置，所以字节序是很重要的。</p> <p>这可能是你的计算机能运行的最简单的程序，但是这是有效的程序，我们可用通过下面2个方式来测试，其中第二中方式对于我们的实验来说更安全和合适的方法。</p> <ul><li>使用你当前的操作系统允许的任何方式来将这这段启动块代码写入一个不重要的储存设备（软盘或者闪存）的第一个扇区，然后重启计算机。</li> <li>使用虚拟机软件，类如：VMWare或者VirtualBox 等，将这段启动块代码作为虚拟机的磁盘镜像，然后启动虚拟机。</li></ul> <p>如果你的计算机启动后没有显示类如：“No operating system found” 这样的没有发现操作系统的提示，而是简单的挂着，你就可以确认你的代码已经被装载并执行了。这是我们放置导代码开始部分的无限循环代码起的作用，如果没有这个无限循环CPU将会崩溃，
一直执行内存中后续的指令，这些指令大多是随机的没有初始化的字节。直到它陷入无效的状态或者重启或者偶然发现并运行BIOS然后格式化主磁盘。
记住，是我们编写控制计算机的，计算机只是机械的取指并执行指令直到关机。所以我们必须确保计算机执行的是我们精心设计的代码而不是内存中某处的随机数据字节。在这种底层水平上，我们对计算机拥有很多的权利和责任，所以我们需要学习如何控制它。</p> <h2 id="_2-3-cpu-模拟"><a href="#_2-3-cpu-模拟" class="header-anchor">#</a> 2.3 CPU 模拟</h2> <p>使用Bochs 或者 Qemu 这样的CPU 模拟器是第三种测试我们底层程序的方式。通过这种方式我们不需要不断的重启计算机或者冒着丢失字盘数据的风险。不像VMware和virthualBox 这样的机器虚拟化，它们通过在宿主机CPU上直接运行客户指令的方式来优化性能，模拟器使用程序来仿真一个特定的CPU架构，使用变量来模拟CPU 的寄存器，使用高级程序控制结构来模拟底层跳转指令等。因此模拟器的速度比较慢，但是通常更适合开发和调试相应的系统。</p> <p>记住，为了让模拟器工作起来，你需要以一个磁盘镜像文件的形式给他一些代码运行。镜像文件就是简单的原始数据（像机器码和数据），或者被写入硬盘，软盘，CDROM，USB等介质中。实际上，某些仿真器是从CDROM下载或提取的映像文件，并从这些文件成功启动并运行实际的操作系统，虽然虚拟化更适合这种使用。</p> <p>模拟器将底层显示设备指令转化为像素并渲染到桌面窗口上。然后就可以在真实显示器上看到你渲染后的内容。</p> <p>通常，对于文档内的练习文件也一样，可以确定的是，任何机器代码只要能正确的运行再模拟器上，就将会正确的运行再真实机器上，显然真实机器跑得更快。</p> <h3 id="_2-3-1-bochs-a-x86-cpu-模拟器"><a href="#_2-3-1-bochs-a-x86-cpu-模拟器" class="header-anchor">#</a> 2.3.1 bochs: A x86 CPU 模拟器</h3> <p>Bochs 需要我们再本地目录下设置一个简单的配置文件-bochsrc, 用来描述设备（显示器和键盘等）将被怎么样模拟的细节，更重要的是描述当模拟器在启动时使用哪个磁盘镜像启动。
图表2.2 显示了一个简单的Bochs 配置文件，我们可以将 xxx 部分写的代码保存为boot_sect.bin，然后使用这个配置文件来测试引导扇区。</p> <div class="language- extra-class"><pre class="language-text"><code># Tell bochs to use our boot sector code as though it were # a floppy disk inserted into a computer at boot time. floppya: 1_44=boot_sect.bin, status=inserted
boot: a

</code></pre></div><p>Figure 2.2 简单的Bochs 配置文件</p> <p>在Bochs上测试引导扇区，在终端输入：</p> <div class="language- extra-class"><pre class="language-text"><code>$bochs
</code></pre></div><p>作为一个简单的实验，让我们试着修改我们的启动扇区上的BIOS 魔法数字为一个无效的数字，然后重启 Bochs.
由于 Bochs 对CPU 的模拟接近真实情况，所以再Bochs 中测试完代码后，你应该能够再真实计算机上启动它，并运行得更快。</p> <h3 id="_2-3-2"><a href="#_2-3-2" class="header-anchor">#</a> 2.3.2</h3> <p>Qemu 与 Bochs 类似，它更方便并且能够模拟x86架构以外的架构。
但是qemu 的文档没有Bochs 完善。qemu 运行很简单，不需要配置文件：</p> <div class="language- extra-class"><pre class="language-text"><code>$qemu &lt;your-os-boot-disk-image-file&gt;

</code></pre></div><h2 id="_2-4-十六进制表示法的优势"><a href="#_2-4-十六进制表示法的优势" class="header-anchor">#</a> 2.4 十六进制表示法的优势</h2> <p>我们已经看到过一些使用16进制的例子了，了解为什么在底层编程
中通常使用16进制是很重要的。
首先考虑一下为什么使用十进制计数对于我们来说如此的自然可能会有帮助，因为当我们第一次看到16进制数时我们总是会问自己：为什么简单的使用十进制呢？我不是这方面的专家，我将做一个假设，使用十进制与大多数手指的总数为10有关，这导致了使用10个不同的符号表示数字的想法：0，1，2，。。。8，9.</p> <p>十进制的底数是10（即有10个不同的数字符号），而十六进制的底数是16，所以我们需要创造一些新的数字符号；偷懒的方法就简单的使用几个字母来表示：0，1，2，...8,9,a,b,c,d,e,f, 例如a表示十进制的13数字。
为了将十六进制系统与其他的数字系统区别开，我们通常使用0x作为前缀，或者使用h作为后缀，对于刚好没有包含任何字母数字的16进制数这很重要，比如0x50 不等于十进制的50 -- 实际上0x50 是十进制的80.
事实是，计算机将数据表示为位的序列（二进制数），因为根本上它的电路只能区分2中电状态：0和1--就像计算机一共只有2个手指，所以为了表示大于1的数字计算机将一系列微位组合再一起，就像我们通过使用2个或以上的数字来表示大雨9的数一样。</p> <p>我们给某些特定长度的位序取名，来使对位序列的交流更容易，也使商定我们处理的数据的大小更容易。大多数计算机的指令最少处理8位值，这些值成为字节，其他的还有short， int， long 分别代表16位，32位，64位的值。我们也见到过 字 这个单词，用户描述CPU当前模式下最大的处理单元的大小。所以再16位实模式下，一个字代表16位值，而再32位保护模式下一个字代表32位值，等等。</p> <p>所以再回头来看 16进制的优势：位字符串写起来相当的耗时，比起与自然的十进制系统相互转换，与十六进制相互转换更容易。本质上是因为我们可以将转换分解为较小的4位二进制片段，而不是将所有的位加起来总计。这对于较大的位字符串很难（例如16，32，64 等）。图表2.3中的事例清晰的显示了十进制转换的困难。</p> <p>图表 2.3: 将1101111010110110 转换位十进制数和十六进制数</p></div> <footer class="page-edit"><!----> <div class="last-updated"><span class="prefix">最近更新:</span> <span class="time">2020/11/30 上午3:20:07</span></div></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/os-dev/introduction.html" class="prev">
        1.1 介绍
      </a></span> <span class="next"><a href="/os-dev/boot-sector-programming.html">
        3.1 启动扇区编程
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.e342ee38.js" defer></script><script src="/assets/js/2.40f8d214.js" defer></script><script src="/assets/js/19.c4607430.js" defer></script>
  </body>
</html>
